<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `C:\Users\DELL\.cargo\registry\src\index.crates.io-6f17d22bba15001f\soroban-env-host-22.1.3\src\host\prng.rs`."><title>prng.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="soroban_env_host" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (90ab8eaed 2024-11-14)" data-channel="nightly" data-search-js="search-6851d9ab.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../../../static.files/src-script-56102188.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">soroban_env_host\host/</div>prng.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers">
<a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a></pre></div><pre class="rust"><code><span class="kw">use super</span>::{declared_size::DeclaredSizeForMetering, metered_clone::MeteredContainer};
<span class="kw">use crate</span>::{
    budget::Budget,
    crypto::{chacha20_fill_bytes, unbias_prng_seed},
    host::metered_clone::MeteredClone,
    host_object::HostVec,
    xdr::{ContractCostType, ScBytes, ScErrorCode, ScErrorType},
    HostError,
};
<span class="kw">use </span>rand::{distributions::Uniform, prelude::Distribution, seq::SliceRandom, RngCore};
<span class="kw">use </span>rand_chacha::{rand_core::SeedableRng, ChaCha20Rng};
<span class="kw">use </span>std::ops::RangeInclusive;

<span class="doccomment">/// PRNG subsystem in the host, which provides best-effort pseudo-randomness to
/// guest contracts using a combination of features that guests cannot easily
/// implement themselves:
///
///   - The host itself maintains one "base" PRNG which should be seeded by the
///     embedding environment and should be different for each host instance, or
///     roughly "each transaction in a block of transactions" so that
///     transactions from different submitters cannot guess one another's seeds.
///     It is the embedder's responsibility to set this to something hard to
///     predict. In the stellar-core embedding, S is set to the combination of
///     the txset hash and the apply-order _position_ of the transaction in the
///     txset, which is itself defined in terms of an xor of each transaction
///     hash and the previous ledger hash. While it is theoretically possible
///     for a validator to guess or influence this, being able to do so also
///     grants validators the ability to front-run the orderbook and is
///     therefore already an attack vector for the whole stellar network's
///     financial integrity. In other words: reusing it here doesn't make
///     anything worse, we're already obliged to make transaction apply-order
///     hard to guess or control.
///
///   - Each frame (which is to say: each contract invocation or sub-invocation)
///     will get a new PRNG instance separately seeded from the host's "base"
///     PRNG, and guest code can only access the frame's PRNG, not the "base"
///     PRNG or those of any other frame. This doesn't eliminate _all_ attack
///     vectors or mechanisms for misuse, but it's the best we can give the user
///     for buiding on. In particular it means that a "random" contract will not
///     behave the same way from one call to the next inside the same txset, nor
///     can a caller control the seed for a "random" callee (since they can't
///     observe the state of the "base" PRNG).
///
///   - Users _can_ reseed their frame-local PRNG if they want, which is a
///     useful building block for random-commitment schemes. In particular if a
///     contract is trying to make a "single random decision", and avoid having
///     callers retry that decision repeatedly while aborting the transaction on
///     any random decision the caller doesn't like, the contract can operate as
///     a state machine like so:
///
///       - tx1: write commitment finalizing all inputs to "random action", plus
///              N = current ledger and S = prng_bytes_new(32).
///
///       - tx2: re-read all committed values, if ledger &gt; N, prng_reseed(S),
///              and use PRNG to take "random" action committed-to.
///
///     With this design, assuming the contract does not expose any _online_
///     method for its caller to observe the commitment it made in tx1, the
///     caller (situated in the same transaction) won't know from its position
///     whether it's to its advantage or not to abort tx1, so will naturally let
///     it commit. Once the commitment is saved, it includes a "locked in"
///     choice of seed, essentially propagating PRNG state out of a context the
///     caller might have been able to influence its state via selective aborts
///     (but didn't know whether to) into a context where the caller can no
///     longer influence its state. The contract can then be re-invoked in the
///     next ledger to load and execute the commitment, in tx2.
///
///   - We also include 3 building blocks for _using_ the PRNG: one basic one
///     that just "generates a random BytesObject" (that the user can do
///     anything they like with, including copying to guest linear memory), and
///     two slightly more subtle but very standard operations that are easy to
///     get wrong: an inclusive-range uniform u64 sampler and a Fisher-Yates
///     vector shuffle. The latter is also hard to do cheaply in guest code
///     without copying the vector into the guest and copying it back.
///
///   - All these PRNGs are ChaCha20: a strong, cheap, standard CSPRNG.
///
</span><span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct </span>Prng(<span class="kw">pub</span>(<span class="kw">crate</span>) ChaCha20Rng);

<span class="kw">pub type </span>Seed = &lt;rand_chacha::ChaCha20Rng <span class="kw">as </span>rand::SeedableRng&gt;::Seed;
<span class="kw">pub const </span>SEED_BYTES: u64 = &lt;Seed <span class="kw">as </span>DeclaredSizeForMetering&gt;::DECLARED_SIZE;
<span class="macro">static_assertions::const_assert_eq!</span>(SEED_BYTES, <span class="number">32</span>);

<span class="kw">impl </span>std::hash::Hash <span class="kw">for </span>Prng {
    <span class="kw">fn </span>hash&lt;H: std::hash::Hasher&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, state: <span class="kw-2">&amp;mut </span>H) {
        <span class="self">self</span>.<span class="number">0</span>.get_seed().hash(state);
        <span class="self">self</span>.<span class="number">0</span>.get_stream().hash(state);
        <span class="self">self</span>.<span class="number">0</span>.get_word_pos().hash(state);
    }
}

<span class="kw">impl </span>Prng {
    <span class="kw">fn </span>charge_prng_bytes(<span class="kw-2">&amp;</span><span class="self">self</span>, budget: <span class="kw-2">&amp;</span>Budget, count: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), HostError&gt; {
        budget.charge(ContractCostType::ChaCha20DrawBytes, <span class="prelude-val">Some</span>(count))
    }

    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>new_from_seed(seed: Seed, budget: <span class="kw-2">&amp;</span>Budget) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, HostError&gt; {
        <span class="kw">let </span>seed = unbias_prng_seed(<span class="kw-2">&amp;</span>seed, budget)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="self">Self</span>(ChaCha20Rng::from_seed(seed)))
    }

    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>u64_in_inclusive_range(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        range: RangeInclusive&lt;u64&gt;,
        budget: <span class="kw-2">&amp;</span>Budget,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;u64, HostError&gt; {
        <span class="comment">// rand::Uniform panics if start &gt; end.
        </span><span class="kw">if </span>range.start() &gt; range.end() {
            <span class="kw">return </span><span class="prelude-val">Err</span>((ScErrorType::Value, ScErrorCode::InvalidInput).into());
        }

        <span class="comment">// We over-estimate the number of bytes drawn by a factor of 2, to
        // account for the fact that a range sample is rejection-sampling which
        // is expected to only do one draw but might do more than one.
        </span><span class="self">self</span>.charge_prng_bytes(budget, <span class="number">2 </span>* &lt;u64 <span class="kw">as </span>DeclaredSizeForMetering&gt;::DECLARED_SIZE)<span class="question-mark">?</span>;
        <span class="kw">let </span>u = Uniform::from(range);
        <span class="prelude-val">Ok</span>(u.sample(<span class="kw-2">&amp;mut </span><span class="self">self</span>.<span class="number">0</span>))
    }

    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>vec_shuffle(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        v: <span class="kw-2">&amp;</span>HostVec,
        budget: <span class="kw-2">&amp;</span>Budget,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;HostVec, HostError&gt; {
        <span class="comment">// A Fisher-Yates shuffle essentially does one call to u64_in_range for
        // each element of the input vector, followed by an optional swap. Since
        // u64_in_range is itself a rejection sampling operation (to avoid bias)
        // we can't be 100% sure how many draws it'll make, but the expected
        // number of draws is 1. To give ourselves a little more safety we'll
        // double that number. We also give the implementation freedom to draw a
        // 64-bit (8-byte) value per index, meaning we charge for generating 2 *
        // 8 * len bytes.
        </span><span class="kw">let </span><span class="kw-2">mut </span>v2 = v.metered_clone(budget)<span class="question-mark">?</span>;
        <span class="comment">// We charge for both the PRNG draws and the swaps here (as "memcpys").
        </span><span class="self">self</span>.charge_prng_bytes(budget, <span class="number">16u64</span>.saturating_mul(v.len() <span class="kw">as </span>u64))<span class="question-mark">?</span>;
        budget.charge(ContractCostType::MemCpy, <span class="prelude-val">Some</span>(v.len() <span class="kw">as </span>u64))<span class="question-mark">?</span>;
        v2.as_mut_slice().shuffle(<span class="kw-2">&amp;mut </span><span class="self">self</span>.<span class="number">0</span>);
        <span class="prelude-val">Ok</span>(v2)
    }

    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>bytes_new(<span class="kw-2">&amp;mut </span><span class="self">self</span>, size: u32, budget: <span class="kw-2">&amp;</span>Budget) -&gt; <span class="prelude-ty">Result</span>&lt;ScBytes, HostError&gt; {
        Vec::&lt;u8&gt;::charge_bulk_init_cpy(size <span class="kw">as </span>u64, budget)<span class="question-mark">?</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>vec = <span class="macro">vec!</span>[<span class="number">0u8</span>; size <span class="kw">as </span>usize];
        chacha20_fill_bytes(<span class="kw-2">&amp;mut </span><span class="self">self</span>.<span class="number">0</span>, vec.as_mut_slice(), budget)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(ScBytes::try_from(vec)<span class="question-mark">?</span>)
    }

    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>sub_prng(<span class="kw-2">&amp;mut </span><span class="self">self</span>, budget: <span class="kw-2">&amp;</span>Budget) -&gt; <span class="prelude-ty">Result</span>&lt;Prng, HostError&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>new_seed: Seed = [<span class="number">0</span>; SEED_BYTES <span class="kw">as </span>usize];
        chacha20_fill_bytes(<span class="kw-2">&amp;mut </span><span class="self">self</span>.<span class="number">0</span>, <span class="kw-2">&amp;mut </span>new_seed, budget)<span class="question-mark">?</span>;
        budget.charge(ContractCostType::MemCpy, <span class="prelude-val">Some</span>(SEED_BYTES))<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="self">Self</span>(ChaCha20Rng::from_seed(new_seed)))
    }

    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>unmetered_raw_sub_prng(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; ChaCha20Rng {
        <span class="kw">let </span><span class="kw-2">mut </span>new_seed: Seed = [<span class="number">0</span>; SEED_BYTES <span class="kw">as </span>usize];
        <span class="self">self</span>.<span class="number">0</span>.fill_bytes(<span class="kw-2">&amp;mut </span>new_seed);
        ChaCha20Rng::from_seed(new_seed)
    }
}
</code></pre></div></section></main></body></html>