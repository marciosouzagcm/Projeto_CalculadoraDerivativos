<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Auth conceptual overview"><title>soroban_env_host::auth - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="soroban_env_host" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (90ab8eaed 2024-11-14)" data-channel="nightly" data-search-js="search-6851d9ab.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../soroban_env_host/index.html">soroban_<wbr>env_<wbr>host</a><span class="version">22.1.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module auth</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#auth-conceptual-overview" title="Auth conceptual overview">Auth conceptual overview</a><ul><li><a href="#invocations" title="Invocations">Invocations</a></li><li><a href="#authorized-invocations" title="Authorized Invocations">Authorized Invocations</a></li></ul></li><li><a href="#addresses" title="Addresses">Addresses</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate soroban_<wbr>env_<wbr>host</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">soroban_env_host</a></span><h1>Module <span>auth</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/soroban_env_host/auth.rs.html#1-2402">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="auth-conceptual-overview"><a class="doc-anchor" href="#auth-conceptual-overview">§</a>Auth conceptual overview</h2>
<p>This module is responsible for two separate tasks (both starting with
“auth”):</p>
<ul>
<li>Authorization: deciding if some action should be allowed by some policy.</li>
<li>Authentication: deciding if some credential or signature is authentic.</li>
</ul>
<p>As one would expect, authorization can (though doesn’t always) depend on
authentication: part of judging whether some action is allowed may depend on
someone presenting a signed credential, at which point one must evaluate the
credential’s authenticity.</p>
<p>Moreover this subsystem is responsible (as will be discussed in detail
below) with facilitating two different <em>directions</em> for each of these tasks:</p>
<ul>
<li>Contracts can <em>require</em> auth services provided by this module.</li>
<li>Contracts can <em>provide</em> auth services required by this module.</li>
</ul>
<p>And again, in both directions the “auth services” required or provided may
be <em>either</em> of authorization, authentication, or both.</p>
<p>All auth services reason about invocations and authorizations, so we
next turn our attention to these.</p>
<h3 id="invocations"><a class="doc-anchor" href="#invocations">§</a>Invocations</h3>
<p>A Soroban transaction can be seen as a tree of <em>invocations</em>: these are
usually invocations of contract functions, but may also be other host
functions requiring authorization, such as the ‘create contract’ function.</p>
<p>The “invocation tree” corresponds to the fact that each invocation may cause
sub-invocations, each of which may have sub-sub-invocations, and so on.
Contracts often invoke other contracts.</p>
<p>Each invocation in the tree is mediated by the Soroban host, and typically
represents a transition between trust domains (as different contracts are
written by different authors), so invocations are the natural boundary at
which to evaluate authorization.</p>
<p>In other words: authorization happens <em>in terms of</em> invocations; they are
the conceptual units for which authorization is granted or denied.</p>
<p>Note that invocations are <em>not</em> function calls within a contract’s own WASM
bytecode. The host can’t see a call from one WASM function to another inside
a single WASM blob, and in general it does not concern itself with authorizing
those. Invocations are bigger: what are often called “cross-contract calls”,
that transfer control from one WASM VM to another.</p>
<h3 id="authorized-invocations"><a class="doc-anchor" href="#authorized-invocations">§</a>Authorized Invocations</h3>
<p>Each invocation may – usually early on – call the host function
<code>require_auth(Address)</code>: this is the main entrypoint to the auth module.</p>
<p>The <code>require_auth</code> function takes an <code>Address</code> that the contract provides,
that identifies some abstract entity responsible for <em>authorizing the
current invocation</em>. The contract calling <code>require_auth</code> must therefore
somehow select (directly or indirectly, perhaps from its own internal
configuration or from some argument it was passed associated with the
operation it’s performing) <em>which entity</em> it wishes to predicate its
execution on the authorization of. As we’ll see, there are multiple ways
this entity may provide authorization. It may also require authorization
from multiple entities!</p>
<p>(There is also a secondary entrypoint called <code>require_auth_for_args</code> that
allows customizing the invocation being authorized, in case the current
contract invocation – function name and argument list – isn’t quite the
one desired, but this distinction is unimportant in this discussion.)</p>
<p>For a given <code>Address</code>, the auth module maintains one or more tree-shaped
data structures called the <code>AuthorizedInvocation</code>s of the <code>Address</code>, which
are incrementally matched by each invocation’s calls to
<code>require_auth(Address)</code>.</p>
<p>Each such tree essentially represents a <em>pattern</em> of invocations the
<code>Address</code> authorizes, that the <em>actual</em> execution context of a running tree
of contract invocations needs to match when it calls <code>require_auth</code>. Any
pattern node that matches an invocation is then permanently <em>associated</em>
with the actual invocation it matched, such that sub-patterns can only match
at actual sub-invocations, allowing the authorizing party to globally
restrict the <em>contexts</em> in which a sub-invocation may match.</p>
<p>Furthermore each pattern node is permanently invalidated as it matches so
that it can never match more than once per transaction. If a user wishes to
authorize two instances of the same pattern within a transaction, they must
provide two separate copies.</p>
<h2 id="addresses"><a class="doc-anchor" href="#addresses">§</a>Addresses</h2>
<p>As described above, <code>AuthorizedInvocation</code>s define the trees of invocations
that are authorized by some <code>Address</code>. But what is an Address? Concretely it
is either a Stellar <code>AccountID</code> or the <code>Hash</code> identity of some contract. But
<em>conceptually</em> the Address used to authorize an invocation may be one of 4
different types.</p>
<ol>
<li>
<p>The address of a contract that is an <em>invoker</em>. We say that if contract
C invokes contract D, then C authorized D. This is simple and requires
no credentials as the host literally observes the call from C to D. It
is a slight conceptual stretch but makes sense: if C didn’t want to
authorize D, it wouldn’t have invoked it! Further invoker-contract
authorizations for <em>indirect</em> calls (C calls D calls E, C wants to
authorize sub-calls to E) can also be provided on the fly by contracts
calling <code>authorize_as_curr_contract</code>, passing a vector of the
Val-encoded type <code>InvokerContractAuthEntry</code>.</p>
</li>
<li>
<p>The address of a Stellar classic account, identified by <code>AccountID</code>,
that must supply <code>SorobanAddressCredentials</code> for any
<code>AuthorizedInvocation</code> it authorizes, satisfying the account’s classic
multisig authorization to its medium threshold.</p>
</li>
<li>
<p>The address of a Stellar classic account that happens to be the
<em>transaction source account</em>. In this case we assume the transaction
signatures already met the requirements of the account before the
Soroban host was even instantiated, and so the <code>AuthorizedInvocation</code>
for such an address can be accompanied by the constant credential
<code>SOROBAN_CREDENTIALS_SOURCE_ACCOUNT</code> that’s considered authentic by
assumption.</p>
</li>
<li>
<p>The address of a contract that is a <em>custom account</em>. In this case the
<code>AuthorizedInvocation</code> is still accompanied by
<code>SorobanAddressCredentials</code> but <em>interpreting</em> those credentials (and
indeed interpreting the entire authorization request) is delegated to a
contract. The contract must export a function called <code>__check_auth</code> and
it will be passed the abstract, uninterpreted <code>Val</code> from the
credential’s “signature” field, along with a hash of the material it
expects the signature to authenticate, and a structured summary of the
auth context. The <code>__check_auth</code> function may potentially re-enter the
auth module by calling <code>require_auth</code> on some other <code>Address</code>.</p>
</li>
</ol>
<p>Each of these 4 forms of address may be passed to <code>require_auth</code>, which will
then serve as a key to look up an <code>AuthorizedInvocation</code> to match against
the invocation being authorized, and potentially perform further
authentication or custom-auth logic.</p>
<p>The first type – contract invoker address – is associated with a set of
<code>AuthorizedInvocation</code>s that is dynamic, evolves during execution of the
transaction, and requires no credentials. The other 3 types are static, are
provided as input to the transaction, and carry credentials that may require
authentication. Therefore the first type and the latter 3 types are tracked
in different data structures. But this is merely an implementation detail;
addresses in all 4 conceptual roles can be passed to <code>require_auth</code> without
any concern for which kind fulfils the requirement at runtime.</p>
<p>In the cases with nontrivial <code>SorobanAddressCredentials</code> (2 and 4), the auth
module takes care of evaluating signature expiration times and recording
nonces to the ledger automatically, to prevent replay.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AuthorizationManager.html" title="struct soroban_env_host::auth::AuthorizationManager">Authorization<wbr>Manager</a></div></li><li><div class="item-name"><a class="struct" href="struct.AuthorizationManagerSnapshot.html" title="struct soroban_env_host::auth::AuthorizationManagerSnapshot">Authorization<wbr>Manager<wbr>Snapshot</a></div></li></ul></section></div></main></body></html>