searchState.loadedDescShard("sodiumoxide", 0, "Rust bindings to the sodium library.\nLibsodium Base64 encoding/decoding helper functions\nCryptographic functions\nLibsodium hexadecimal encoding/decoding helper functions\n<code>init()</code> initializes the sodium library and chooses faster …\nCryptographic random number generation.\nLibsodium utility functions\nLibsodium version functions\nBase64 as defined in RFC 4648 §4\nBase64 as defined in RFC 4648 §4 but without padding\nBase64 as defined in RFC 4648 §5\nBase64 as defined in RFC 4648 §5 but without padding\nSupported variants of Base64 encoding/decoding\nDecodes a Base64 string into a byte sequence using the …\nEncodes a byte sequence as a Base64 string using the given …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAuthenticated Encryption with Additional Data This …\nSecret-key authentication\nPublic-key authenticated encryption\n<code>GenericHash</code>.\nHashing\nKey derivation\nKey exchange\nSecret-key One-time authentication\nPassword Hashing\nScalar multiplication\nSealed Boxes\nSecret-key authenticated encryption\nStream encryption/file encryption\nA lot of applications and programming language …\nPublic-key signatures\nSecret-key encryption\nConstant-time comparison of fixed-size vecs\nThe original ChaCha20-Poly1305 construction can safely …\nThe IETF variant of the ChaCha20-Poly1305 construction can …\nThe XChaCha20-Poly1305 construction can safely encrypt a …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric authenticated encryption with additional …\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric authenticated encryption with …\nNumber of bytes in an authentication <code>Tag</code>.\nAuthentication <code>Tag</code> for symmetric authenticated encryption …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a secret key\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>open()</code> verifies and decrypts a ciphertext <code>c</code> together with …\n<code>open_detached()</code> verifies and decrypts a ciphertext <code>c</code> …\n<code>seal()</code> encrypts and authenticates a message <code>m</code> together …\n<code>seal_detached()</code> encrypts and authenticates a message <code>m</code> …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric authenticated encryption with additional …\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric authenticated encryption with …\nNumber of bytes in an authentication <code>Tag</code>.\nAuthentication <code>Tag</code> for symmetric authenticated encryption …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a secret key\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>open()</code> verifies and decrypts a ciphertext <code>c</code> together with …\n<code>open_detached()</code> verifies and decrypts a ciphertext <code>c</code> …\n<code>seal()</code> encrypts and authenticates a message <code>m</code> together …\n<code>seal_detached()</code> encrypts and authenticates a message <code>m</code> …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric authenticated encryption with additional …\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric authenticated encryption with …\nNumber of bytes in an authentication <code>Tag</code>.\nAuthentication <code>Tag</code> for symmetric authenticated encryption …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a secret key\n<code>gen_nonce</code> randomly generates a nonce\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>open()</code> verifies and decrypts a ciphertext <code>c</code> together with …\n<code>open_detached()</code> verifies and decrypts a ciphertext <code>c</code> …\n<code>seal()</code> encrypts and authenticates a message <code>m</code> together …\n<code>seal_detached()</code> encrypts and authenticates a message <code>m</code> …\n<code>HMAC-SHA-256</code> <code>HMAC-SHA-256</code> is conjectured to meet the …\n<code>HMAC-SHA-512</code> <code>HMAC-SHA-512</code> is conjectured to meet the …\n<code>HMAC-SHA-512-256</code>, i.e., the first 256 bits of <code>HMAC-SHA-512</code>…\nNumber of bytes in a <code>Key</code>.\nAuthentication <code>Key</code>\nAuthentication <code>State</code>\nNumber of bytes in a <code>Tag</code>.\nAuthentication <code>Tag</code>\n<code>authenticate()</code> authenticates a message <code>m</code> using a secret …\n<code>finalize()</code> finalizes the authenticator computation and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for authentication\n<code>init()</code> initializes an authentication structure using a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>update()</code> can be called more than once in order to compute …\n<code>verify()</code> returns <code>true</code> if <code>tag</code> is a correct authenticator of …\nNumber of bytes in a <code>Key</code>.\nAuthentication <code>Key</code>\nAuthentication <code>State</code>\nNumber of bytes in a <code>Tag</code>.\nAuthentication <code>Tag</code>\n<code>authenticate()</code> authenticates a message <code>m</code> using a secret …\n<code>finalize()</code> finalizes the authenticator computation and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for authentication\n<code>init()</code> initializes an authentication structure using a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>update()</code> can be called more than once in order to compute …\n<code>verify()</code> returns <code>true</code> if <code>tag</code> is a correct authenticator of …\nNumber of bytes in a <code>Key</code>.\nAuthentication <code>Key</code>\nAuthentication <code>State</code>\nNumber of bytes in a <code>Tag</code>.\nAuthentication <code>Tag</code>\n<code>authenticate()</code> authenticates a message <code>m</code> using a secret …\n<code>finalize()</code> finalizes the authenticator computation and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for authentication\n<code>init()</code> initializes an authentication structure using a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>update()</code> can be called more than once in order to compute …\n<code>verify()</code> returns <code>true</code> if <code>tag</code> is a correct authenticator of …\n<code>crypto_box_curve25519xsalsa20poly1305</code> , a particular …\nNumber of bytes in the authenticator tag of an encrypted …\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for asymmetric authenticated encryption\nNumber of bytes in a <code>PrecomputedKey</code>.\nNumber of bytes in a <code>PublicKey</code>.\nApplications that send several messages to the same …\n<code>PublicKey</code> for asymmetric authenticated encryption\nNumber of bytes in a <code>SecretKey</code>.\nNumber of bytes in a <code>Seed</code>.\n<code>SecretKey</code> for asymmetric authenticated encryption\n<code>Seed</code> that can be used for keypair generation\nAuthentication <code>Tag</code> for the detached encryption mode\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_keypair()</code> randomly generates a secret key and a …\n<code>gen_nonce()</code> randomly generates a nonce\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>key_pair_from_seed()</code> deterministically derives a key pair …\n<code>open()</code> verifies and decrypts a ciphertext <code>c</code> using the …\n<code>open_detached()</code> verifies and decrypts a ciphertext <code>c</code> using …\n<code>open_detached_precomputed()</code> verifies and decrypts a …\n<code>open_precomputed()</code> verifies and decrypts a ciphertext <code>c</code> …\n<code>precompute()</code> computes an intermediate key that can be used …\n<code>public_key()</code> computes the corresponding public key for a …\n<code>seal()</code> encrypts and authenticates a message <code>m</code> using the …\n<code>seal_detached()</code> encrypts and authenticates a message <code>m</code> …\n<code>seal_detached_precomputed()</code> encrypts and authenticates a …\n<code>seal_precomputed()</code> encrypts and authenticates a message <code>m</code> …\nMaximum of allowed bytes in a <code>Digest</code>\nMinimium of allowed bytes in a <code>Digest</code>\nDigest-structure\nMaximum of allowed bytes in a key\nMinimium of allowed bytes in a key\n<code>State</code> contains the state for multi-part (streaming) hash …\n<code>finalize</code> finalizes the state and returns the digest value. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>new</code> constructs and initializes a new <code>State</code> with the given …\n<code>update</code> updates the <code>State</code> with <code>data</code>. <code>update</code> can be called …\n<code>SHA-256</code>.\n<code>SHA-512</code>.\nBlock size of the hash function.\nNumber of bytes in a <code>Digest</code>.\nDigest-structure\n<code>State</code> contains the state for multi-part (streaming) hash …\n<code>finalize</code> finalizes the state and returns the digest value. …\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>hash</code> hashes a message <code>m</code>. It returns a hash <code>h</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>new</code> constructs and initializes a new <code>State</code>.\n<code>update</code> updates the <code>State</code> with <code>data</code>. <code>update</code> can be called …\nBlock size of the hash function.\nNumber of bytes in a <code>Digest</code>.\nDigest-structure\n<code>State</code> contains the state for multi-part (streaming) hash …\n<code>finalize</code> finalizes the state and returns the digest value. …\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>hash</code> hashes a message <code>m</code>. It returns a hash <code>h</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>new</code> constructs and initializes a new <code>State</code>.\n<code>update</code> updates the <code>State</code> with <code>data</code>. <code>update</code> can be called …\n<code>blake2b</code> is the current default key derivation scheme of …\nMaximum number of bytes in a subkey.\nMinimum number of bytes in a subkey.\nNumber of bytes in a <code>Context</code>\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for key derivation.\n<code>derive_from_key</code> derives the subkey_id-th subkey from the …\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for key derivation.\nCalls <code>U::from(self)</code>.\n<code>x25519blake2b</code> is the current default key exchange scheme …\nNumber of bytes in a <code>PublicKey</code>.\n<code>PublicKey</code> for key exchanges.\nNumber of bytes in a <code>SecretKey</code>.\nNumber of bytes in a <code>Seed</code>.\nNumber of bytes in a <code>SessionKey</code>.\n<code>SecretKey</code> for key exchanges.\n<code>Seed</code> that can be used for keypair generation\n<code>SessionKey</code> is returned by <code>client_session_keys</code> and …\n<code>client_session_keys()</code> computes a pair of shared keys (rx …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_keypair()</code> randomly generates a secret key and a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>keypair_from_seed()</code> computes a secret key and a …\n<code>server_session_keys()</code> computes a pair of shared keys (rx …\n<code>crypto_onetimeauth_poly1305</code>, an authenticator specified in …\nNumber of bytes in a <code>Key</code>.\nAuthentication <code>Key</code>\nNumber of bytes in a <code>Tag</code>.\nAuthentication <code>Tag</code>\n<code>authenticate()</code> authenticates a message <code>m</code> using a secret …\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for authentication\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>verify()</code> returns <code>true</code> if <code>tag</code> is a correct authenticator of …\nArgon2 summarizes the state of the art in the design of …\nArgon2 summarizes the state of the art in the design of …\n<code>crypto_pwhash_scryptsalsa208sha256</code>, a particular …\nNumber of bytes in a <code>HashedPassword</code>.\n<code>HashedPassword</code>is a password verifier generated from a …\nSafe base line for <code>MemLimit</code> for interactive password …\n<code>MemLimit</code> for moderately sensitive data.\n<code>MemLimit</code> for highly sensitive data.\n<code>MemLimit</code> represents the maximum amount of RAM that the …\nSafe base line for <code>OpsLimit</code> for interactive password …\n<code>OpsLimit</code> for moderately sensitive data.\n<code>OpsLimit</code> for highly sensitive data.\n<code>OpsLimit</code> represents the maximum number of computations to …\nNumber of bytes in a <code>Salt</code>.\nAll <code>HashedPasswords</code> start with this string.\n<code>Salt</code> used for password hashing\nVariant id for the Argon2i13 algorithm\nThe <code>derive_key()</code> function derives a key from a password …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_salt()</code> randomly generates a new <code>Salt</code> for key derivation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>pwhash()</code> returns a <code>HashedPassword</code> which includes:\n<code>pwhash_verify()</code> verifies that the password <code>str_</code> is a valid …\nNumber of bytes in a <code>HashedPassword</code>.\n<code>HashedPassword</code>is a password verifier generated from a …\nSafe base line for <code>MemLimit</code> for interactive password …\n<code>MemLimit</code> for moderately sensitive data.\n<code>MemLimit</code> for highly sensitive data.\n<code>MemLimit</code> represents the maximum amount of RAM that the …\nSafe base line for <code>OpsLimit</code> for interactive password …\n<code>OpsLimit</code> for moderately sensitive data.\n<code>OpsLimit</code> for highly sensitive data.\n<code>OpsLimit</code> represents the maximum number of computations to …\nNumber of bytes in a <code>Salt</code>.\nAll <code>HashedPasswords</code> start with this string.\n<code>Salt</code> used for password hashing\nVariant id for the Argon2i13 algorithm\nThe <code>derive_key()</code> function derives a key from a password …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_salt()</code> randomly generates a new <code>Salt</code> for key derivation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>pwhash()</code> returns a <code>HashedPassword</code> which includes:\n<code>pwhash_verify()</code> verifies that the password <code>str_</code> is a valid …\nNumber of bytes in a <code>HashedPassword</code>.\n<code>HashedPassword</code>is a password verifier generated from a …\nSafe base line for <code>MemLimit</code> for interactive password …\n<code>MemLimit</code> for highly sensitive data.\n<code>MemLimit</code> represents the maximum amount of RAM that the …\nSafe base line for <code>OpsLimit</code> for interactive password …\n<code>OpsLimit</code> for highly sensitive data.\n<code>OpsLimit</code> represents the maximum number of computations to …\nNumber of bytes in a <code>Salt</code>.\nAll <code>HashedPasswords</code> start with this string.\n<code>Salt</code> used for password hashing\nThe <code>derive_key()</code> function derives a key from a password …\n<code>derive_key_interactive()</code> is a shortcut function for …\n<code>derive_key_sensitive()</code> is a shortcut function for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_salt()</code> randombly generates a new <code>Salt</code> for key …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>pwhash()</code> returns a <code>HashedPassword</code> which includes:\n<code>pwhash_interactive()</code> is a shortcut function for <code>pwhash()</code> …\n<code>pwhash_sensitive()</code> is a shortcut function for <code>pwhash()</code> with\n<code>pwhash_verify()</code> verifies that the password <code>str_</code> is a valid …\n<code>crypto_scalarmult_curve25519</code> specified in Cryptography in …\nNumber of bytes in a <code>GroupElement</code>.\n<code>GroupElement</code>\nNumber of bytes in a <code>Scalar</code>.\n<code>Scalar</code> value (integer in byte representation)\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>scalarmult()</code> multiplies a group element <code>p</code> by an integer <code>n</code>. …\n<code>scalarmult_base()</code> computes the scalar product of a standard\nA particular combination of <code>Curve25519</code>, <code>Blake2B</code>, <code>XSalsa20</code> …\nNumber of additional bytes in a ciphertext compared to the …\nThe <code>open()</code> function decrypts the ciphertext <code>c</code> using the …\nThe <code>seal()</code> function encrypts a message <code>m</code> for a recipient …\n<code>crypto_secretbox_xsalsa20poly1305</code>, a particular …\nNumber of bytes in <code>Key</code>.\n<code>Key</code> for symmetric authenticated encryption\nNumber of bytes in the authenticator tag of an encrypted …\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric authenticated encryption\nAuthentication <code>Tag</code> for the detached encryption mode\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a secret key\n<code>gen_nonce()</code> randomly generates a nonce\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>open()</code> verifies and decrypts a ciphertext <code>c</code> using a secret …\n<code>open_detached()</code> verifies and decrypts a ciphertext <code>c</code> and …\n<code>seal()</code> encrypts and authenticates a message <code>m</code> using a …\n<code>seal_detached()</code> encrypts and authenticates a message <code>m</code> …\n<code>crypto_secretstream_xchacha20poly1305</code>\nNumber of added bytes. The ciphertext length is guaranteed …\nFinal: indicates that the message marks the end of the …\nNumber of bytes in a <code>Header</code>. An encrypted stream starts …\nAn encrypted stream starts with a short header, whose size …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric authenticated encryption.\nMessage, the most common tag, that doesn’t add any …\nRepresents the pull mode of a Stream.\nRepresents the push mode of a Stream.\nPush: indicates that the message marks the end of a set of …\nRekey: “forget” the key used to encrypt this message …\n<code>Stream</code> contains the state for multi-part (streaming) …\nThe trait that distinguishes between the pull and push …\nA tag is encrypted and attached to each message before the …\nCreate a ciphertext for an empty message with the <code>TAG_FINAL</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a secret key\nInitializes a <code>Stream&lt;Pull&gt;</code> given a secret <code>Key</code> and a <code>Header</code>…\nInitializes an <code>Stream</code> using a provided <code>key</code>. Returns the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the stream is finalized.\nReturns true if the stream is not finalized.\nReturns the maximum length of an individual message.\nVerifies that <code>c</code> is a valid ciphertext with a correct …\nVerifies that <code>c</code> is a valid ciphertext with a correct …\nAll data (including optional fields) is authenticated. …\nAll data (including optional fields) is authenticated. …\nExplicit rekeying. This updates the internal state of the …\n<code>SipHash-2-4</code>\nNumber of bytes in a <code>Digest</code>.\n<code>Digest</code> structure\nNumber of bytes in a <code>Key</code>.\n<code>Key</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for shorthash\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>shorthash</code> hashes a message <code>m</code> under a key <code>k</code>. It returns a …\n<code>ed25519</code>, a signature scheme specified in Ed25519. This …\nNumber of bytes in a <code>PublicKey</code>.\n<code>PublicKey</code> for signatures\nNumber of bytes in a <code>SecretKey</code>.\nNumber of bytes in a <code>Seed</code>.\nNumber of bytes in a <code>Signature</code>.\n<code>SecretKey</code> for signatures\n<code>Seed</code> that can be used for keypair generation\nDetached signature\nState for multi-part (streaming) computation of signature.\n<code>finalize()</code> finalizes the hashing computation and returns a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_keypair()</code> randomly generates a secret key and a …\n<code>init()</code> initialize a streaming signing state.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>keypair_from_seed()</code> computes a secret key and a …\n<code>public_key()</code> computes the corresponding public key for a …\n<code>sign()</code> signs a message <code>m</code> using the signer’s secret key <code>sk</code>…\n<code>sign_detached()</code> signs a message <code>m</code> using the signer’s …\n<code>update()</code> can be called more than once in order to compute …\n<code>verify()</code> verifies the signature in <code>sm</code> using the signer’s …\n<code>veriry</code> verifies the signature in <code>sm</code> using the signer’s …\n<code>verify_detached()</code> verifies the signature in <code>sig</code> against …\n<code>crypto_stream_chacha20</code> (Chacha20)\n<code>crypto_stream_salsa20</code> (Salsa20/20), a particular cipher …\n<code>xchacha20</code>. The same construction as <code>xsalsa20</code> but using …\n<code>crypto_stream_xsalsa20</code>, a particular cipher specified in …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric encryption\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric encryption\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for symmetric encryption\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>stream()</code> produces a <code>len</code>-byte stream <code>c</code> as a function of a …\n<code>stream_xor()</code> encrypts a message <code>m</code> using a secret key <code>k</code> and …\n<code>stream_xor_ic()</code> encrypts a message <code>m</code> using a secret key <code>k</code> …\n<code>stream_xor_ic_inplace()</code> encrypts a message <code>m</code> using a …\n<code>stream_xor_inplace()</code> encrypts a message <code>m</code> using a secret …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric encryption\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric encryption\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for symmetric encryption\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>stream()</code> produces a <code>len</code>-byte stream <code>c</code> as a function of a …\n<code>stream_xor()</code> encrypts a message <code>m</code> using a secret key <code>k</code> and …\n<code>stream_xor_ic()</code> encrypts a message <code>m</code> using a secret key <code>k</code> …\n<code>stream_xor_ic_inplace()</code> encrypts a message <code>m</code> using a …\n<code>stream_xor_inplace()</code> encrypts a message <code>m</code> using a secret …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric encryption\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric encryption\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for symmetric encryption\n<code>gen_nonce</code> randomly generates a nonce\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>stream()</code> produces a <code>len</code>-byte stream <code>c</code> as a function of a …\n<code>stream_xor()</code> encrypts a message <code>m</code> using a secret key <code>k</code> and …\n<code>stream_xor_ic()</code> encrypts a message <code>m</code> using a secret key <code>k</code> …\n<code>stream_xor_ic_inplace()</code> encrypts a message <code>m</code> using a …\n<code>stream_xor_inplace()</code> encrypts a message <code>m</code> using a secret …\nNumber of bytes in a <code>Key</code>.\n<code>Key</code> for symmetric encryption\nNumber of bytes in a <code>Nonce</code>.\n<code>Nonce</code> for symmetric encryption\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>from_slice()</code> creates an object from a byte slice\n<code>from_slice()</code> creates an object from a byte slice\n<code>gen_key()</code> randomly generates a key for symmetric encryption\n<code>gen_nonce</code> randomly generates a nonce\n<code>increment_le()</code> treats the nonce as an unsigned …\n<code>increment_le_inplace()</code> treats the nonce as an unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>stream()</code> produces a <code>len</code>-byte stream <code>c</code> as a function of a …\n<code>stream_xor()</code> encrypts a message <code>m</code> using a secret key <code>k</code> and …\n<code>stream_xor_ic()</code> encrypts a message <code>m</code> using a secret key <code>k</code> …\n<code>stream_xor_ic_inplace()</code> encrypts a message <code>m</code> using a …\n<code>stream_xor_inplace()</code> encrypts a message <code>m</code> using a secret …\n<code>verify_16()</code> returns <code>true</code> if <code>x[0]</code>, <code>x[1]</code>, …, <code>x[15]</code> are the …\n<code>verify_32()</code> returns true if <code>x[0]</code>, <code>x[1]</code>, …, <code>x[31]</code> are the …\n<code>verify_64()</code> returns true if <code>x[0]</code>, <code>x[1]</code>, …, <code>x[63]</code> are the …\nParses a hexadecimal string into a byte sequence.\nEncodes byte sequence into a hexadecimal string.\n<code>randombytes()</code> randomly generates size bytes of data.\n<code>randombytes_into()</code> fills a buffer <code>buf</code> with random data.\n<code>randombytes_uniform()</code> returns an unpredictable value …\n<code>add_le()</code> treats <code>x</code> and <code>y</code> as unsigned little-endian numbers …\n<code>increment_le()</code> treats <code>x</code> as an unsigned little-endian …\n<code>memcmp()</code> returns true if <code>x[0]</code>, <code>x[1]</code>, …, <code>x[len-1]</code> are the …\n<code>memzero()</code> tries to effectively zero out the data in <code>x</code> even …\n<code>mlock()</code> locks memory given region which can help avoiding …\n<code>munlock()</code> unlocks memory region.\n<code>version_major()</code> returns the major version from libsodium.\n<code>version_minor()</code> returns the minor version from libsodium.\n<code>version_string()</code> returns the version string from libsodium.")